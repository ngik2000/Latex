%5_2.tex

本研究ではベクトル拡張付きRISC-Vの命令の内，プレディケートなしのベクトル算術・論理演算命令，即値によるシフト命令を実装している．

図\ref{fig:add_array_c}
のアセンブリコードでもベクトルロード・ストア命令等の命令についてはベクトル拡張付きRISC-Vのベクトルロード・ストア命令が生成できていない．ベクトル拡張付きRISC-V命令の内，ベクトルロード・ストア命令，プレディケート付きベクトル演算命令，ベクトル制御命令について未実装である．
これらの命令の実装には本研究で行ったように命令の実装のみならず，新たなレジスタの定義に加えてLLVM IRへの変更が必要である．

新たなレジスタの定義についてだが，これは本研究で実装していないベクトル命令で用いられているプレディケートレジスタの定義が必要である．ベクトル拡張付きRISC-Vではプレディケートレジスタを用いたベクトル処理を行うことによってスケーラブルなベクトル拡張を実現している．そのためプレディケートレジスタが必須であるがRISC-Vはプレディケートレジスタを有していない．
そのため，新たにプレディケートレジスタを定義する必要がある．また，定義したプレディケートレジスタをそれを用いる命令のオペランドに割りあてられるようにするなど，命令とレジスタの定義のみでは実装が難しい．

また，LLVMによる自動ベクトル化が行われたLLVM IRではベクトル処理がベクトル演算の繰り返しと余りの要素の処理で行われているのに対して，ベクトル拡張付きRISC-Vではプレディケートレジスタを用いたベクトル処理を行っており，余りの要素の処理はプレディケートレジスタを用いた計算を行っている．
そのため，現在のLLVM IRからベクトル拡張付きRISC-Vのプレディケートレジスタを用いる命令を効果的に生成することができないため，ベクトル化されたLLVM IRについて変更が必要である．現在のLLVM IRにおけるベクトル処理は，ベクトル演算の繰り返しと逐次処理によって配列演算等を行っている．しかし，ベクトル拡張付きRISC-Vではプレディケートレジスタを用いたベクトル演算のみで配列演算を行っているため，ベクトル化LLVM IRをベクトル演算のみの状態で自動で生成できるように変更が必要である．

本研究では，機能の再利用のしやすさや自動ベクトル化機能を有していることから，LLVMを用いてベクトル拡張付きRISC-Vの命令コード生成を行った．しかし，LLVMの他にもオープンソースのコンパイラとしてGCCがある．GCCでも自動ベクトル化を行うことは可能なため，LLVMのみならずGCC等のコンパイラにおいてもベクトル拡張付きRISC-Vの命令生成を行うことも課題として挙げられる．