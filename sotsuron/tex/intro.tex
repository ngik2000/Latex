%intro.tex
FPGA(Field Programmable Gate Array)はユーザによって回路の再構成が可能なLSIであり，目的の処理をハードウェアとして実装可能なデバイスである．
近年FPGAの大容量化，高性能化によって大規模な回路が実現可能になった．これによりFPGAは自動運転を始めとする組込み分野での利用増加が期待されている．

FPGAを用いたハードウェア開発はHDL(Hardware Description Language)によるRTL(Register Transfer Level)設計が広く用いられている．RTLはFPGA上に構成する回路の信号の流れや制御構造を直接設計できる一方，動作検証やデバックが難しく，短期間で複雑な処理の開発は困難である．\cite{bib:fpga}
そのため，FPGAによる開発期間を短縮する方法として，専用ハードディスクとプロセッサを用いたソフトウェアによる処理を組み合わせる方法が考えられる．FPGA上のハードウェアリソースを用いて実装するプロセッサのことをソフトコアプロセッサという．
一般的に組込みシステムではそのコストやサイズ，消費電力などに制限があるためハードウェア資源に制約があることが多く，メモリバンド幅が限られることからメモリシステムの性能が高くないことが多い．メモリシステムの性能が低いと演算性能を高くしてもメモリアクセスに時間がかかり，結果としてシステム全体の性能はメモリシステムの性能によって左右される．\cite{bib:2}
そこで，ソフトコアプロセッサによる処理を考える．すべての処理を専用ハードウェア回路で行うのではなく，高い性能の求められない汎用的な処理についてはソフトコアプロセッサにて行うことにより開発する専用ハードウェア回路を削減でき，ソフトコアプロセッサの性能が向上して専用ハードウェア回路を削減しても求められた性能に達することができればハードウェアの開発コストを抑えることができる．

組込み分野ではAI技術に注目が集まっている．独立行政法人情報処理推進機構の調査によると，将来強化/新たに獲得したい技術として組込み/IoT関連企業の46\%がAI技術を挙げている．\cite{bib:ipa}

AI技術の応用としては画像認識などの画像処理が行われる．画像処理では画像を構成する画素に対して同じ処理を行うようなものが多い．このように複数のデータに対して同じ演算を行う処理については，単一命令で複数データの処理を行うSIMD(Single Instruction, Multiple Data)や，複数命令を並列に実行するMIMD(Multiple Instruction, Multiple Data)による並列処理で高速化が可能である．\cite{bib:simd,mimd}
MIMDは複数の制御を並列化することができるため，異なる処理を同時に実行するアプリケーションでは有効である．しかし，プロセッサに複数の制御ユニットをもたせる必要があるためSIMDと比較するとハードウェアのコストが大きくなる．一方SIMDは単一の制御ユニットで複数の演算ユニットを並列動作させるため制御ユニットのコストは低くなる．
データ並列処理では複数のデータに対して同じ処理を実行するためSIMDによって並列処理が可能である．

SIMDによる並列処理を行う場合，SIMD命令は1命令で演算するデータ数が決まっている．そのため演算性能を上げるために同時演算数を変更すると機械語コードを作り直す必要がある．異なる同時演算数でも同一の機械語コードを利用可能とするためには，機械語コードが同時演算数に依存しないスケーラブルなベクトル拡張が必要である．スケーラブルなベクトル拡張により機械語コードを変更することなく，必要に応じて容易に同時演算数を増やし高性能化することが可能となる．

スケーラブルなベクトル拡張を実現したものとしてオープンな命令セットアーキテクチャであるRISC-V\cite{bib:risc-v}をベクトル拡張したベクトル拡張付きRISC-V\cite{bib:kimura}が提案されている．ベクトル拡張付きRISC-Vは組込み機器に広く用いられているARMのベクトル拡張であるARM SVE(Scalable Vector Extension)\cite{bib:arm_sve}の命令セットを参考に組み込み向けにRISC-Vに拡張したものである．しかし，ベクトル拡張付きRISC-Vに対応したコンパイラが存在していない．そこで解決策としてベクトル拡張付きRISC-Vのベクトル命令のアセンブリコードを得るためのコンパイラの開発を検討した．

本論文では，第2章で現在のMIQSプロセッサについて述べる．第3章でベクトル拡張付きRISC-V命令の生成のために利用したコンパイラ基盤であるLLVMについて述べる．第4章で実際に命令生成のための実装について述べる．第5章では実際のソースコードからアセンブリコードの出力を行った結果について述べる．